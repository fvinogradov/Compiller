     Однако в общем случае задача сканера несколько шире, чем просто проверка цепочки символов лексемы на соответствие ее входному языку. Сканер должен выполнить те или иные действия по запоминанию распознанной лексемы (занесение ее в таблицу лексем). Набор действий определяется реализацией компилятора. Обычно эти действия выполняются сразу же по обнаружению конца распознаваемой лексемы, поэтому их несложно вставить в соответствующие места рассмотренной выше программы-сканера (в те операторы, где обнаруживается символ #0).
     Вторая проблема, которая уже обсуждалась выше, это выделение границ лексем. Ведь во входном тексте лексемы не ограничены специальными символами. Если говорить в терминах программы-сканера, то определение границ лексем - это выделение тех строк в общем потоке входных символов, для которых надо выполнять распознавание. В общем случае эта задача может быть сложной, но для простейших входных языков границы лексем распознаются по заданным терминальным символам. Эти символы - пробелы, знаки операций, символы комментариев, а также разделители (запятые, точки с запятой и др.). Набор таких терминальных символов может варьироваться в зависимости от входного языка. Важно отметить, что знаки операций сами также являются лексемами, и необходимо не пропустить их при распознавании текста.
     Таким образом, алгоритм работы простейшего сканера можно описать так:
        * просматривается входной поток символов программы на исходном языке до обнаружения очередного символа, ограничивающего лексему;
        * для выбранной части входного потока выполняется функция распознавания лексемы;
        * при успешном распознавании информация о выделенной лексеме заносится в таблицу лексем, и алгоритм возвращается к первому этапу;
        * при неуспешном распознавании выдается сообщение об ошибке, а дальнейшие действия зависят от реализации сканера - либо его выполнение прекращается, либо делается попытка распознать следующую лексему (идет возврат к первому этапу алгоритма).
     Работа программы-сканера продолжается до тех пор, пока не будут просмотрены все символы программы на исходном языке из входного потока.
ПОРЯДОК ВЫПОЛНЕНИЯ РАБОТЫ
1. Получить вариант задания у преподавателя.
2. Разработать КС-грамматику входного языка в соответствии с заданием.
3. Написать и отладить программу на ЭВМ.
4. Сдать работающую программу преподавателю.
5. Подготовить и защитить отчет.
ТРЕБОВАНИЯ К ОФОРМЛЕНИЮ ОТЧЕТА
     Отчет должен содержать следующие разделы:
1. Задание по лабораторной работе.
2. Описание КС-грамматики входного языка в форме Бэкуса-Наура.
3. Описание алгоритма работы сканера или граф конечного автомата для распознавания цепочек (в соответствии с вариантом задания).
4. Текст программы (оформляется после выполнения программы на ЭВМ).
5. Выводы по проделанной работе.
ОСНОВНЫЕ КОНТРОЛЬНЫЕ ВОПРОСЫ
      1. Что такое трансляция, компиляция, транслятор, компилятор ? 
      2. Из каких процессов состоит компиляция ? Расскажите об общей структуре компилятора.
      3. Какую роль выполняет лексический анализ в процессе компиляции ?
      4. Как связаны лексический и синтаксический анализ ?
      5. Дайте определение цепочки, языка. Что такое синтаксис и семантика языка ?
      6. Какие существуют методы задания языков ? Какие дополнительные вопросы необходимо решить при задании языка программирования ?
      7. Что такое грамматика ? Дайте определения грамматики.
      8. Как выглядит описание грамматики в форме Бэкуса-Наура.
      9. Какие классы грамматик существуют ? Что такое регулярные грамматики ?
      10. Дайте определения контекстно-свободной грамматики, выводимости цепочки, непосредственной выводимости, длины вывода.
      11. Что такое конечный автомат? Дайте определение детерминированного и недетерминированного конечных автоматов.
      12. Какие проблемы необходимо решить при построении сканера на основе конечного автомата ?
ВАРИАНТЫ ЗАДАНИЙ
      1. Входной язык содержит арифметические выражения, разделенные символом; (точка с запятой). Арифметические выражения состоят из идентификаторов, десятичных чисел с плавающей точкой (в обычной и логарифмической форме), знаков операций и скобок.
      2. Входной язык содержит арифметические выражения, разделенные символом ;(точка с запятой). Арифметические выражения состоят из идентификаторов, римских чисел, знаков операций и скобок. (Римскими считать числа записанные большими буквами X, V и I).
        3. Входной язык содержит упрощенные операторы цикла типа
while <логическое выражение> do <оператор присваивания>; Логическое выражение может содержать идентификаторы, знаки операций сравнения, целые десятичные числа без знака, скобки и логические операции and и or. Оператор присваивания должен состоять из идентификатора, знака присваивания и целой десятичной константы без знака.
        4. Входной язык содержит упрощенные условные операторы типа
if <логическое выражение> then <оператор присваивания> else <оператор присваивания>; (часть else в операторе может отсутствовать). Логическое выражение может содержать идентификаторы, знаки операций сравнения, целые десятичные числа без знака, скобки и логические операции and и not. Оператор присваивания должен состоять из двух идентификаторов, разделенных знаком присваивания.
        5. Входной язык содержит выражения над строковыми константами, разделенные символом ;(точка с запятой). Выражения состоят из идентификаторов, строковых констант, заключенных в двойные кавычки, одиночных символов, заключенных в одинарные кавычки и знаков операции конкатенации.
        6. Входной
