     Цель работы: изучение основных принципов генерации компилятором объектного кода для линейного участка программы, ознакомление с методами оптимизации результирующего объектного кода с помощью свертки и исключения лишних операций.
     Для выполнения лабораторной работы требуется написать программу, которая на основании дерева синтаксического разбора порождает объектный код и выполняет затем его оптимизацию. В качестве исходного дерева синтаксического разбора рекомендуется взять дерево, которое порождает программа, построенная по заданию предыдущей лабораторной работы.
     Программу рекомендуется построить из трех основных частей: первая часть - порождение дерева синтаксического разбора (по результатам лабораторной работы №3), вторая часть - реализация алгоритма порождения объектного кода по дереву разбора, и третья часть - оптимизация порожденного объектного кода. Результатам работы должна быть построенная на основании заданного предложения грамматики программа на объектном языке. В качестве объектного языка предлагается взять язык ассемблера для процессоров типа Intel 80x86 в реальном  режиме (возможен выбор другого объектного языка по согласованию с преподавателем). Все встречающиеся в исходной программе идентификаторы считать простыми скалярными переменными, не требующими выполнения преобразования типов. Ограничения на длину идентификаторов и констант соответствуют требованиям предыдущей лабораторной работы.
КРАТКИЕ ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
     Генерация объектного кода - это перевод компилятором внутреннего представления исходной программы в результирующую объектную программу на языке ассемблера или непосредственно на машинном языке (машинных кодах).
     Генерация объектного кода выполняется после того, как выполнен синтаксический анализ программы и все необходимые действия по подготовке к генерации кода: распределено адресное пространство под функции и переменные, проверено соответствие имен и типов переменных, констант и функций в синтаксических конструкциях исходной программы и т.д.
     Оптимизация программы - это обработка, связанная с переупорядочиванием и изменением операций в компилируемой программе с целью получения более эффективной результирующей объектной программы. Оптимизация выполняется на этапах подготовки к генерации и непосредственно при генерации объектного кода.
     Лучшие оптимизирующие компиляторы могут получать объектные программы из сложных исходных программ, написанных на языках высокого уровня, почти не уступающие по качеству программам на языке ассемблера. Временные и трудовые затраты на создание такой программы существенно меньше, чем при ее реализации на ассемблере. У современных компиляторов существуют возможности выбора тех или иных критериев оптимизации, исходя из которых оценивается эффективность объектной программы. Так, с одной стороны, возможна оптимизация с минимизацией размера программы, с другой стороны - оптимизация с увеличением скорости ее выполнения. При этом не требуется изменять текст программы на исходном языке.
     Все эти преимущества говорят в пользу применения оптимизации. Единственным, но существенным недостатком оптимизации является необходимость тщательной ее проработки при создании компилятора. Используемые методы оптимизации ни при каких условиях не должны приводить к изменению “смысла” исходной программы (т.е. к таким ситуациям, когда результат выполнения программы изменяется после ее оптимизации). К сожалению, не все методы оптимизации, используемые создателями компиляторов, могут быть теоретически обоснованы и доказаны для всех возможных видов исходных программ. Поэтому большинство компиляторов предусматривает возможность отключать те или иные из возможных методов оптимизации. (Часто при оптимизации компиляторы выдают предупреждения разработчику программы, если тот или иной ее участок вызывает подозрения в отношении правильности его “смысла”). Применение оптимизации также нецелесообразно в процессе отладки исходной программы.
     Различаются две основные категории оптимизирующих преобразований:
* преобразования исходной программы (в форме ее внутреннего представления в компиляторе), не зависящие от результирующего объектного языка;
* преобразования результирующей объектной программы.
     Последний тип преобразований может зависеть не только от свойств объектного языка (что очевидно), но и от архитектуры вычислительной системы, на которой будет выполняться результирующая программа. (Так, например, при оптимизации может учитываться объем кэш-памяти и методы организации конвейерных операций центрального процессора). Этот тип преобразований здесь рассматриваться не будет. Именно эти преобразования могут повлиять на “смысл” исходной программы. В большинстве случаев они являются “ноу-хау” производителей компиляторов и строго ориентированы на определенные архитектуры вычислительных машин.
     Методы преобразования программы зависят от типов синтаксических конструкций исходного языка. Теоретически разработаны методы оптимизации для многих типовых конструкций языков программирования. Далее будут рассмотрены только методы оптимизации линейных участков - они встречаются в любой программе и составляют существенную часть программного кода.
     Линейный участок программы - это выполняемая по порядку последовательность операций имеющая один вход и один выход. Чаще всего линейный участок содержит последовательность арифметических операций и операторов присвоения значений переменным.
     Прежде чем перейти к вопросам оптимизации линейных участков рассмотрим их внутренне представление в компиляторе.
     Возможны различные формы внутреннего представления синтаксических конструкций исходной программы в компиляторе. На этапе синтаксического разбора часто используется форма, именуемая деревом вывода (методы его построения рассматривались в предыдущих лабораторных работах). Но формы представления, используемые на этапах синтаксического анализа, оказываются неудобными в работе при генерации и оптимизации объектного кода. Поэтому перед оптимизацией и непосредственно генерацией объектного кода внутреннее представление программы преобразуется в одну из соответствующих форм записи.
     Примерами таких форм записи являются:
* обратная польская запись операций;
* тетрады операций;
* триады операций;
* собственно команды ассемблера.
     Обратная польская запись - это постфиксная запись операций. Преимуществом ее является то, что все операции записываются непосредственно в порядке их выполнения. Она чрезвычайно эффективна в тех случаях, когда для вычислений используется стек.
     Тетрады представляют собой запись операций в форме из четырех составляющих:
<операция>(<операнд1>,<операнд2>,<результат>). Тетрады используются редко, так как требуют больше памяти для своего представления, чем триады, не отражают взаимосвязи операций и, кроме того, плохо отображаются в команды ассемблера и машинные коды, так как в наборах команд большинства современных машин не встречаются операции с тремя операндами.
     Триады представляют собой запись операций в форме из трех составляющих: <операция>(<операнд1>,<операнд2>), при этом один или оба операнда могут быть ссылками на другую триаду в том случае, если в качестве операнда данной триады выступает результат выполнения другой триады. Поэтому триады при записи последовательно номеруют для удобства указания ссылок одних триад на другие. Например, выражение записанное в виде триад будет иметь вид:
     Здесь операции обозначены соответствующим знаком (при этом присвоение также является операцией), а знак ^ означает ссылку операнда одной триады на результат другой.
     Команды ассемблера удобны тем, что при их использовании внутреннее представление программы полностью соответствует объектному коду и сложные преобразования не требуются. Однако использование команд ассемблера требует дополнительных структур для отображения их взаимосвязи. Кроме того, внутреннее представление программы получается зависимым от результирующего кода, а это значит, что при ориентации компилятора на другой результирующий код потребуется перестраивать как само внутреннее представление программы, так и методы его обработки в алгоритмах оптимизации (при использовании триад или тетрад этого не требуется).
     Для построения внутреннего представления объектного кода (в дальнейшем - просто кода) по дереву вывода 
      
